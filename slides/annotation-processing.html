<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Pluggable Annotation Processing API</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="reveal.js/css/theme/beige.css"/>


    <!-- For syntax highlighting using highlight.js-->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

  <link rel="stylesheet" media="print" href="reveal.js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Pluggable Annotation Processing API</h1>
    <h3 class="date">JUG Toulouse - 2015 - LTE Consulting</h3>
</section>

<section id="arnaud-tournier" class="slide level3">
<h1>Arnaud Tournier</h1>
<p><strong>ArchiDév</strong> passionné chez <strong>LTE Consulting</strong></p>
<p>Speaker <strong>Devoxx</strong>, <strong>GWT.create</strong>, <strong>Paris</strong>/<strong>Toulouse JUG</strong>, etc...</p>
<p><span class="citation" data-cites="ltearno">@ltearno</span> www.lteconsulting.fr</p>
<p><strong>Full stack (x86_64 to JavaScript)</strong> !</p>
</section>
<section><section id="jsr-269" class="titleslide slide level2"><h1>JSR 269 ???</h1></section><section id="section" class="slide level3">
<h1></h1>
<p>La JSR 269 - Pluggable Annotation Processing API permet d'exploiter les annotations présentes dans le code en s'insérant dans le processus de compilation.</p>
<ul>
<li>Traitement des annotations à la compilation,</li>
<li>Génération de code,</li>
<li>Génération de fichiers de configuration,</li>
<li>Vérifications,</li>
<li>etc...</li>
</ul>
<p>On ne modifie pas les sources existants !</p>
</section></section>
<section><section id="avantages" class="titleslide slide level2"><h1>Avantages</h1></section><section id="section-1" class="slide level3">
<h1></h1>
<p>Le code généré est visible.</p>
<p>Pas de traitement au runtime donc pas d'impact sur les performances.</p>
<p>Pas d'instrumentation du byte-code, donc plus simple.</p>
</section></section>
<section><section id="brève-histoire-du-traitement-des-annotations" class="titleslide slide level2"><h1>Brève histoire du traitement des annotations</h1></section><section id="commentaires-javadoc" class="slide level3">
<h1>Commentaires Javadoc</h1>
<p>XDoclet</p>
<pre><code>/****
* Account entity bean
*
* @ejb.bean
*     name=&quot;bank/Account&quot;
*     jndi-name=&quot;ejb/bank/Account&quot;
*     primkey-field=&quot;id&quot;
*     schema = &quot;Customers&quot;
* ...
*/
public class MonBean { ... }</code></pre>
</section><section id="apt" class="slide level3">
<h1>APT</h1>
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/">Annotation Processing Tool</a>, retiré officiellement avec Java 7 car <a href="http://openjdk.java.net/jeps/117">non extensible à Java &gt; 5</a>.</p>
<p>Outil lancé en dehors de la compilation. L'API Mirror utilise les packages <code>com.sun.mirror</code>.</p>
</section><section id="pluggable-annotation-processing-api" class="slide level3">
<h1>Pluggable Annotation Processing API</h1>
<p>Depuis 2006 (java 6) la <a href="https://jcp.org/aboutJava/communityprocess/final/jsr269/index.html">JSR-269</a>, créé par Joe Darcy.</p>
<p>Intégré à la compilation <code>javac</code>.</p>
</section></section>
<section><section id="principe" class="titleslide slide level2"><h1>Principe</h1></section><section id="section-2" class="slide level3">
<h1></h1>
<ul>
<li>On fournit un processeur d'annotation,</li>
<li>Le compilateur gère des <code>rounds</code> de processing,</li>
<li>A chaque round, les nouveaux sources sont traités (phases <em>Parse</em> et <em>Enter</em>),</li>
<li>Les processeurs sont choisis et reçoivent l'AST des classes traitées,</li>
<li>Les processeurs peuvent générer de nouveaux fichiers (<em>sources</em>, <em>classes</em> et <em>resources</em>) qui seront parsés et traités au <code>round</code> suivant.</li>
</ul>
</section></section>
<section><section id="exemple" class="titleslide slide level2"><h1>Exemple</h1></section><section id="création-de-lannotation" class="slide level3">
<h1>Création de l'annotation</h1>
<pre><code>import java.lang.annotation.*;

// package, class, method, ...
@Target( value = { ElementType.METHOD } )
@Retention( RetentionPolicy.SOURCE )
public @interface MonAnnotation
{
    ...
}</code></pre>
</section><section id="le-processeur" class="slide level3">
<h1>Le processeur</h1>
<pre><code>@SupportedAnnotationTypes( value= { &quot;fr.lteconsulting.MonAnnotation&quot; } )
@SupportedSourceVersion( SourceVersion.RELEASE_6 )
public class MonAnnotationProcessor extends AbstractProcessor  {
    @Override
    public boolean process( Set&lt;?&gt; extends TypeElement&gt; annotations,
                            RoundEnvironment roundEnv ) {
        Types typeUtils = processingEnv.getTypeUtils();
        Elements elementUtils = processingEnv.getElementUtils();
        Messager messager = processingEnv.getMessager();

        for ( TypeElement element : roundEnv.getElementsAnnotatedWith(MonAnnotation.class) )
            processingEnv.getMessager().printMessage(
                Diagnostic.Kind.NOTE,
                element.getQualifiedName());
        return true;
    }
}</code></pre>
</section><section id="le-fichier-spi" class="slide level3">
<h1>Le fichier SPI</h1>
<p>Pour packager un processeur, le plus simple est d'utiliser SPI :</p>
<p>Le fichier <code>META-INF/services/javax.annotation.processing.Processor</code> contient la liste des processeurs :</p>
<pre><code>fr.lteconsulting.MyAnnotationProcessor</code></pre>
<p><strong>Packager le tout dans un jar et le tour est joué !</strong></p>
</section><section id="un-bout-de-code" class="slide level3">
<h1>Un bout de code</h1>
<p>Dans un autre projet on peut utiliser l'annotation et le processeur.</p>
<p>Il suffit d'avoir le jar du processeur dans le classpath.</p>
<pre><code>class UneClasse {
    @MonAnnotation
    void uneMethode()
    {
        ...
    }
}</code></pre>
</section><section id="packaging-et-compilation" class="slide level3">
<h1>Packaging et compilation</h1>
<p>Le processeur et le fichier SPI sont dans un jar.</p>
<p>Ce jar est dans le class path au moment de la compilation.</p>
<p>C'est tout !</p>
<p>TODO dire où sont générés les classes générées</p>
</section><section id="sortie-de-notre-exemple" class="slide level3">
<h1>Sortie de notre exemple</h1>
<pre><code>fr.lteconsulting.UneClasse.uneMethode()</code></pre>
</section><section id="exemples-en-ligne" class="slide level3">
<h1>Exemples en ligne</h1>
<ul>
<li>http://thecodersbreakfast.net/index.php?post/2009/07/09/Enforcing-design-rules-with-the-Pluggable-Annotation-Processor</li>
</ul>
</section></section>
<section><section id="fonctionnement" class="titleslide slide level2"><h1>Fonctionnement</h1></section><section id="section-3" class="slide level3">
<h1></h1>
<p>A chaque round, le processeur doit traiter les classes générées au round précédent. S'il est appelé au premier round, il le sera pour les autres, jusqu'au dernier round (même si aucune annotation n'est présente pour lui).</p>
</section><section id="découverte-des-processeurs" class="slide level3">
<h1>Découverte des processeurs</h1>
<p>Les proceseurs sont découverts par le compilateur. <code>JavaCompiler</code> fournit des options pour controller l'ensemble des processeurs disponibles :</p>
<ul>
<li>une liste prédéfinie,</li>
<li>un chemin de recherche,</li>
<li>utiliser SPI.</li>
</ul>
</section><section id="choix-du-processeur" class="slide level3">
<h1>Choix du processeur</h1>
<p>Appel des processeurs en fonction :</p>
<ul>
<li>des annotations présentes dans les classes traitées,</li>
<li>les annotations supportées par tel processeur,</li>
<li>le fait qu'un processeur ait <em>claimé</em> une annotation.</li>
</ul>
</section><section id="cycle-de-vie-du-processeur" class="slide level3">
<h1>Cycle de vie du processeur</h1>
<ul>
<li>Le compilateur instancie le processeur,</li>
<li>Appelle <code>init</code> avec un <code>ProcessingEnvironment</code>,</li>
<li>Appelle <code>getSupportedAnnotationTypes</code>, <code>getSupportedOptions</code> et <code>getSupportedSourceVersion</code>,</li>
<li>Et appelle <code>process</code> à chaque round.</li>
</ul>
</section><section id="a-chaque-round" class="slide level3">
<h1>A chaque round</h1>
<ul>
<li>javac calcule l'ensemble des annotations sur les classes en cours,</li>
<li>si au moins une annotation est présente, au fur et à mesure que les processeurs les <em>claime</em>, elles sont retirées des annotations non <em>matchées</em>.</li>
<li>quand l'ensemble est vide ou qu'il n'y a plus de processeur candidat, le round est fini.</li>
<li>si aucune annotation n'est présente, seuls les processeurs <em>universels</em> (&quot;*&quot;) sont appelés, et reçoivent un ensemble vide.</li>
</ul>
</section><section id="précautions" class="slide level3">
<h1>Précautions !</h1>
<ul>
<li>Un processeur ne doit pas dépendre d'un autre,</li>
<li>Idempotent,</li>
<li>Commutatif.</li>
</ul>
</section><section id="linterface-processor" class="slide level3">
<h1>L'interface Processor</h1>
<p><a href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html"><code>javax.annotation.processing.Processor</code></a></p>
<pre><code>void init( ProcessingEnvironment processingEnv );

Set&lt;String&gt; getSupportedAnnotationTypes();

boolean process(    Set&lt;? extends TypeElement&gt; annotations,
                    RoundEnvironment roundEnv );</code></pre>
</section><section id="processingenvironment" class="slide level3">
<h1>ProcessingEnvironment</h1>
<p><a href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html"><code>javax.annotation.processing.ProcessingEnvironment</code></a></p>
<pre><code>// Utilitaires
Elements getElementUtils();
Types getTypeUtils();
Locale getLocale();
Map&lt;String, String&gt; getOptions();
SourceVersion getSourceVersion();

// Création de fichiers
Filer getFiler();

// Affichage utilisateur
Messager getMessager();</code></pre>
<p>TODO : décrire ces choses</p>
</section><section id="getsupportedannotationtypes" class="slide level3">
<h1>getSupportedAnnotationTypes</h1>
<ul>
<li><code>*</code></li>
<li><code>fr.lteconsulting.annotations.*</code></li>
<li><code>fr.lteconsulting.annotations.MonAnnotation</code></li>
</ul>
</section><section id="la-méthode-process" class="slide level3">
<h1>La méthode process</h1>
<pre><code>boolean process(    Set&lt;? extends TypeElement&gt; annotations,
                    RoundEnvironment roundEnv)</code></pre>
<ul>
<li>On reçoit l'ensemble des annotations à traiter</li>
<li>On retourne <code>true</code> pour empêcher les autres processeurs d'être appelés</li>
</ul>
</section><section id="roundenvironment" class="slide level3">
<h1>RoundEnvironment</h1>
<p><a href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html"><code>javax.annotation.processing.RoundEnvironment</code></a></p>
<p>Liste des classes dans le round :</p>
<pre><code>Set&lt;? extends Element&gt; getRootElements()</code></pre>
<p>Liste des éléments annotés :</p>
<pre><code>Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a)
Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a)</code></pre>
</section><section id="element" class="slide level3">
<h1>Element</h1>
<p><a href="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/Element.html">javax.lang.model.element.Element</a></p>
<p>Représente un <em>package</em>, une <em>classe</em>, une <em>méthode</em>, ...</p>
<p>Pour parcourir les données d'un élément, il faut soit appeler <code>getKind()</code> soit utiliser un visiteur.</p>
<p><strong>Ne pas utiliser <code>instanceof</code> !</strong></p>
</section><section id="element-1" class="slide level3">
<h1>Element</h1>
<pre><code>// Visiter l&#39;élément :
&lt;R,P&gt; R accept(ElementVisitor&lt;R,P&gt; v, P p);

// Obtenir le type :
TypeMirror asType();

// Demander la sorte :
ElementKind getKind();

// Demander les annotations présentes sur l&#39;élément :
List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors();
&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType);

// Autres :
// getModifiers(); getSimpleName(); getEnclosingElement(); getEnclosedElements();</code></pre>
</section><section id="les-sortes-delement" class="slide level3">
<h1>Les sortes d'Element</h1>
<p><code>ElementKind</code></p>
<p><em>annotation, class, constructeur, enum, une constante enum, parametre d'exception, champ, initializeur d'instance, interface, variable locale, méthode, package, paramètre, variable de resource, initializeur statique, paramètre de type, autres</em> (futur).</p>
</section><section id="récupérer-un-type" class="slide level3">
<h1>Récupérer un type</h1>
<pre><code>TypeMirror serializable = processingEnv.getElementUtils().getTypeElement(Serializable.class.getCanonicalName()).asType();</code></pre>
</section><section id="le-filer" class="slide level3">
<h1>Le Filer</h1>
<p><a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/Filer.html"><code>javax.annotation.processing.Filer</code></a></p>
</section><section id="section-4" class="slide level3">
<h1></h1>
<p>Créer un nouveau source java</p>
<pre><code>Filer filer = processingEnv.getFiler();
JavaFileObject jfo = filer.createSourceFile(
     classElement.getQualifiedName() + &quot;Info&quot;);
PrintWriter pw = new PrintWriter( jfo );
...</code></pre>
</section><section id="section-5" class="slide level3">
<h1></h1>
<p>Créer une nouvelle resource</p>
<pre><code>Filer filer = processingEnv.getFiler();
try {
    PrintWriter pw = new PrintWriter(filer.createResource(
          StandardLocation.SOURCE_OUTPUT, &quot;&quot;, &quot;Todo.txt&quot;)
          .openOutputStream());
    pw.println(&quot;Quelque chose&quot;);
    pw.close();
} catch (IOException ioe) {
    messager.printMessage(Kind.ERROR, ioe.getMessage());
}</code></pre>
</section><section id="utilisation-de-templates" class="slide level3">
<h1>Utilisation de templates !</h1>
<ul>
<li>Velocity, ...</li>
<li>Ne générer que le minimum de code !</li>
</ul>
</section><section id="le-messager" class="slide level3">
<h1>Le Messager</h1>
<pre><code>messager.printMessage( Kind.ERROR, 
    &quot;Cette classe n&#39;a pas de champ ID : &quot; + clazz.getSimpleName() );

// sortie :
error: Cette classe n&#39;a pas de champ ID : fr.lteconsulting.Data
1 error</code></pre>
<p>MONTRER L'ERREUR DE COMPILATION ET UNE COPIE D'ECRAN ECLIPSE</p>
</section></section>
<section><section id="la-compilation-java" class="titleslide slide level2"><h1>La compilation Java</h1></section><section id="phases" class="slide level3">
<h1>3 phases</h1>
<figure>
<img src="javac-flow.png" alt="Plan d&#39;exécution de javac" /><figcaption>Plan d'exécution de javac</figcaption>
</figure>
<ul>
<li><em>Parse</em> et <em>Enter</em></li>
<li><em>Annotation Processing</em></li>
<li><em>Analyse</em> et <em>Generate</em></li>
</ul>
<p>http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html</p>
</section><section id="javac" class="slide level3">
<h1>JavaC</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Action</th>
<th style="text-align: left;">Paramètres</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Génération des sources</td>
<td style="text-align: left;">-s <em>répertoire</em></td>
</tr>
<tr class="even">
<td style="text-align: left;">Désigner un processeur</td>
<td style="text-align: left;">-processor <em>fr.lteconsulting.MyAnnotationProcessor</em>,<em>autre...</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Spécifier un chemin de recherche</td>
<td style="text-align: left;">-processorPath <em>le_chemin</em></td>
</tr>
<tr class="even">
<td style="text-align: left;">Passer des options</td>
<td style="text-align: left;">-A<em>cle=valeur</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Désactiver l'AP</td>
<td style="text-align: left;">-proc:none</td>
</tr>
<tr class="even">
<td style="text-align: left;">Seulement l'AP</td>
<td style="text-align: left;">-proc:only</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO</td>
<td style="text-align: left;">-sourcePath</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO</td>
<td style="text-align: left;">-implicit:none</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO</td>
<td style="text-align: left;">-d</td>
</tr>
<tr class="even">
<td style="text-align: left;">Affichage debug</td>
<td style="text-align: left;">-XprintRounds -XprintProcessorInfo</td>
</tr>
</tbody>
</table>
<p>TODO autres options</p>
<p>ATTENTION : le warning si on ne met pas <em>-implicit:none</em></p>
<p>http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html#searching</p>
</section><section id="packaging-maven" class="slide level3">
<h1>Packaging Maven</h1>
<ul>
<li>artefact <em>Annotations</em>,</li>
<li>artefact <em>Processeurs</em>,</li>
<li>artefacts <em>clients</em>.</li>
</ul>
</section><section id="packaging-maven-1" class="slide level3">
<h1>Packaging Maven</h1>
<ul>
<li>artefact <em>Annotations</em>,</li>
<li>artefact <em>Processeurs</em>,</li>
<li>artefacts <em>clients</em>.</li>
</ul>
</section></section>
<section><section id="intégration-dans-eclipse" class="titleslide slide level2"><h1>Intégration dans Eclipse</h1></section><section id="section-6" class="slide level3">
<h1></h1>
<p>Eclipse utilise son propre compilateur, JDT.</p>
<figure>
<img src="eclipse-settings.png" alt="Settings Eclipse" /><figcaption>Settings Eclipse</figcaption>
</figure>
<p>Montrer aussi le messager</p>
<p>Il faut configurer le projet ou utiliser m2e, ou autre...</p>
</section></section>
<section><section id="limitations" class="titleslide slide level2"><h1>Limitations</h1></section><section id="section-7" class="slide level3">
<h1></h1>
<ul>
<li>Pas possible de modifier des classes existantes</li>
<li>Certains bug ne permettent pas de traiter correctement les génériques</li>
</ul>
</section><section id="hacking-au-delà" class="slide level3">
<h1>Hacking au delà</h1>
<ul>
<li>Lombok : quelques hack pour accéder à l'implémentation (javac de sun et jdt) et modifier l'AST</li>
<li>Immutables : quelques workaround captant les implementations JDK / JDT pour gérer les génériques</li>
</ul>
</section></section>
<section><section id="tests-unitaires" class="titleslide slide level2"><h1>Tests unitaires</h1></section></section>
<section><section id="utilisations" class="titleslide slide level2"><h1>Utilisations</h1></section><section id="section-8" class="slide level3">
<h1></h1>
<ul>
<li>Dagger,</li>
<li>Google Auto,</li>
<li>Immutables,</li>
<li>Hexa Binding,</li>
<li>Lombok,</li>
<li>GWT,</li>
<li>JPA model generation (JSR-317)</li>
</ul>
</section><section id="lombok" class="slide level3">
<h1>Lombok</h1>
<ul>
<li>http://stackoverflow.com/questions/6107197/how-does-lombok-work</li>
</ul>
</section></section>
<section><section id="liens" class="titleslide slide level2"><h1>Liens</h1></section><section id="section-9" class="slide level3">
<h1></h1>
<p><a href="http://jmdoudoux.developpez.com/cours/developpons/java/chap-annotations.php#annotations-8">JM Doudoux</a></p>
</section></section>
<section><section id="pas-traités..." class="titleslide slide level2"><h1>Pas traités...</h1></section></section>
<section><section id="email-eugene-lucas-immutables" class="titleslide slide level2"><h1>email Eugene Lucas (Immutables)</h1></section></section>
<section><section id="email-question-m.-gruber-dagger" class="titleslide slide level2"><h1>email question M. Gruber (Dagger)</h1></section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,
        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
